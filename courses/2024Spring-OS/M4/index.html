<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>M4(可选实验之一)：C Read-Eval-Print-Loop (crepl) | Xintao Niu (钮鑫涛)</title> <meta name="author" content="Xintao Niu"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://niuxintao.github.io/courses/2024Spring-OS/M4/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="//">Xintao Niu (钮鑫涛)</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/awards/">Awards&amp;Grants</a> </li> <li class="nav-item "> <a class="nav-link" href="/courses/">Courses</a> </li> <li class="nav-item "> <a class="nav-link" href="/members/">Members</a> </li> <li class="nav-item "> <a class="nav-link" href="/research/">Research</a> </li> <li class="nav-item "> <a class="nav-link" href="/services/">Services</a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Talks</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">M4(可选实验之一)：C Read-Eval-Print-Loop (crepl)</h1> <p class="post-meta">December 6, 2024</p> <p class="post-tags"> <a href="//blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote class="block-warning"> <h6 id="soft-deadline-2024-年-5-月-26-日-235959">⏰Soft Deadline: 2024 年 5 月 26 日 23:59:59</h6> <p><strong>你需要首先阅读<a href="https://niuxintao.github.io/courses/2024Spring-OS/lab/">实验须知</a>，其中包含了代码获取方法、提交方法、如何查看提交结果等</strong>。在命令行中 <code class="language-plaintext highlighter-rouge">git pull origin M4</code> 下载框架代码。</p> </blockquote> <h3 id="1-背景">1. 背景</h3> <p>现代编程语言提供交互式语言运行环境 <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="external nofollow noopener" target="_blank">read-eval-print-loop</a>(REPL): python, node, 就连 Java 都引入了 jshell。例如 Python Shell (以及更方便的 Jupyter Notebook) 可以快速帮助大家解决高等数学作业、高精度计算等烦恼：</p> <center> <img src="/assets/img/python-repl.svg" width="700"> </center> <p><br></p> <p>你会预期 C 语言同样也可以实现 “交互式” 的 shell，支持即时定义函数，而且能计算 C表达式的数值。如果你输入一行代码，比如<code class="language-plaintext highlighter-rouge">strlen("Hello World")</code>，这段代码会经历 gcc 编译、动态加载、调用执行，最终把代码执行得到的数值 <code class="language-plaintext highlighter-rouge">11</code> 打印到屏幕上。这就是本实验的内容。</p> <h3 id="2-实验描述">2. 实验描述</h3> <p><code class="language-plaintext highlighter-rouge">crepl</code> - 逐行从 stdin 中输入单行 C 语言代码，并根据输入内容分别处理：</p> <ul> <li>如果输入一个 C 函数的定义，则把函数编译并加载到进程的地址空间中；</li> <li>如果输入是一个 C 语言表达式，则把它的值输出。</li> </ul> <h4 id="描述">描述</h4> <p>解释执行每一行标准输入中的 C “单行” 代码 (假设我们只使用 <code class="language-plaintext highlighter-rouge">int</code> 类型，即所有输入的表达式都是整数；定义函数的返回值也永远是整数)，分如下两种情况：</p> <h5 id="1-函数">(1) 函数</h5> <p>为了简化实验与操作系统无关的细节，如果输入的字符串 (一行) 以 <code class="language-plaintext highlighter-rouge">int</code> 开头，我们就认为它是一个函数。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div> <p>函数接收若干 <code class="language-plaintext highlighter-rouge">int</code> 类型的参数，返回一个 <code class="language-plaintext highlighter-rouge">int</code> 数值。如果一行是一个函数，我们希望它将会经过 gcc 编译，并被加载到当前进程的地址空间中。函数可以引用之前定义过的函数。</p> <h5 id="2-表达式">(2) 表达式</h5> <p>如果一行不是以 <code class="language-plaintext highlighter-rouge">int</code> 开头，我们就认为这一行是一个 C 语言的<strong>表达式</strong> ，其类型为 <code class="language-plaintext highlighter-rouge">int</code>，例如</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div></div> <blockquote class="block-tip"> <h6 id="️实验要求函数和表达式均可以调用之前定义过的函数">🗒️实验要求：函数和表达式均可以调用之前定义过的函数</h6> <p>这对于交互式的 C Shell 来说是 “自然” 的需求。我们假设，函数和表达式都不会访问全局的状态 (变量) 或调用任何库函数。如果一行既不是合法的函数 (例如调用了不允许调用的函数)，也不是合法的表达式，<code class="language-plaintext highlighter-rouge">crepl</code> 可以不保证它们执行的结果 (不一定要报告错误，例如你的程序依然可以照常编译或执行，但你的程序要尽量不会 crash)；重复定义重名函数你也可以当做 undefined behavior 不必做出过多处理——我们的测试用例中没有这样的情况。</p> </blockquote> <blockquote class="block-danger"> <h6 id="️实现交互式的-repl">⚠️实现交互式的 REPL</h6> <p>在本实验中，我们要求你实现交互式的 REPL，即主进程能即时获得所有表达式的值，因此请保证 <strong>在接收到表达式后立即打印，并使用<code class="language-plaintext highlighter-rouge">fflush</code>(stdout)清空缓冲区</strong>。偷懒的做法是把所有表达式拼接起来成一个程序打印；但本实验中不能这么做。</p> </blockquote> <p>以下是我们的参考实现：</p> <center> <img src="/assets/img/crepl-demo.gif" width="700"> </center> <p><br></p> <p>我们的参考实现调用了 pygments 实现了语法高亮，展示了一种可能性，但你完全没有做这件事情的必要，我们也不鼓励这么做。我们对大家只有最简的实验要求：你只要你为每一个函数或表达式输出一行 (包含结果) 即可，例如你可以把你的 crepl 实现成这样：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./crepl-64
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
OK.
gcd(256, 144) * gcd(56, 84)
= 448.
</code></pre></div></div> <p>这个实验表明，编译和解释并没有明确的边界——在 OpenJDK 的实现中，即便是 “解释器” 也是编译的 (只是没有经过优化)。动态 (just-in-time) 技术在程序运行时 (而非程序执行前) 进行编译，并将编译得到的二进制代码 (指令/数据) 动态加载。其中最成功的案例之一是 Sun (现在是 Oracle) 的 Java 虚拟机 <a href="https://wiki.openjdk.java.net/display/HotSpot/Main" rel="external nofollow noopener" target="_blank">HotSpot</a> (现在是OpenJDK的一部分)，它使 Java 彻底摆脱了 “性能低下” 的诟病，也是引领 Web 热潮的核心后端技术。另一个最成功的案例是 JavaScript 的 <a href="https://v8.dev/" rel="external nofollow noopener" target="_blank">V8 引擎</a>。借助 Webkit/v8，Chrome 成功地把微软公司的 Internet Explorer 拖下神坛，并且奠定了 Google 在互联网技术领域的霸主地位。</p> <h3 id="3-正确性标准">3. 正确性标准</h3> <p>你只要能正确解析单行的函数 (以 <code class="language-plaintext highlighter-rouge">int</code> 开头)，并且默认其他输入都是表达式即可。我们可能会输入不合法的 C 代码 (例如不合法的表达式)；你的程序应该给出错误提示而不应该 crash。你可以做出比较友好的假设——不像之前的实验，会为了 “强迫” 你掌握某些知识而使你疯狂 Wrong Answer。这个实验纯属放松，Online Judge 没有刁难你的测试用例，都和 demo 中的差不多。</p> <ul> <li>注意我们允许函数和表达式调用之前 (在 crepl 中) 定义过的函数；</li> <li>你可以假设我们输入的命令/表达式数量不超过 100 个；</li> <li>注意你处在的运行目录可能没有写入的权限。建议你将创建的临时文件都放在 <code class="language-plaintext highlighter-rouge">/tmp/</code> 目录下。建议使用 <code class="language-plaintext highlighter-rouge">mkstemp</code> family API 创建临时文件；</li> <li>主进程确实求出了所有表达式的值。</li> <li>禁止使用 C 标准库 system 和 popen。这稍稍增加了实验的难度，不过并没有增加多少。请把这个限制理解成强迫大家掌握操作系统知识的训练。</li> </ul> <blockquote class="block-danger"> <h6 id="️实禁止使用-system-和-popen">⚠️实禁止使用 system() 和 popen()</h6> <p>为了 “强迫” 大家实现正确的 REPL，调用 system 和 popen 会导致编译错误。好消息是这个实验我们不禁止 <code class="language-plaintext highlighter-rouge">exec</code> family 的系统调用：execl, execlp, execle, execv, execvp, execvpe 都是允许的。</p> </blockquote> <h3 id="4-实验指南">4. 实验指南</h3> <h4 id="41-解析读入的命令">4.1 解析读入的命令</h4> <p>框架代码里已经包含了读入命令的循环 (看起来像是一个小 shell)，它打印出一个提示符，然后接受输入并解析：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"crepl&gt; "</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">stdin</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// To be implemented.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Got %zu chars.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>当你在终端里按下 Ctrl-d，会结束 stdin 输入流，fgets 会得到 <code class="language-plaintext highlighter-rouge">NULL</code>。</p> <p>这段代码里一个有趣的小细节是对 fflush 的调用：你会发现把它去掉对程序的运行并没有什么影响。但如果你在 fgets 之前插入一些延迟，例如 <code class="language-plaintext highlighter-rouge">sleep(1)</code>，你会发现 fgets 会 flush stdout 的缓冲区。但 C 标准并没有规定这个行为，glibc 只是因为大家用错得太多，为大家贴心地兜了——其实 System 领域这种 “事实行为” 并不少见，大家错得多了，我们的库函数、编译器等不得不做出防御性的行为容忍大家犯错。一个例子是某一时期本的 gcc 会非常激进地对能证明的 undefined behavior 进行优化，但却导致不少以前 “正确” 工作的代码的崩溃，到新版本里反而不再做这些激进的优化了。</p> <p>回到实验，在上面的代码里，如果读入的字符串以 <code class="language-plaintext highlighter-rouge">int</code> 开头，你就可以假设是一个函数；否则就可以假设是一个表达式。</p> <h4 id="42-把函数编译成共享库">4.2 把函数编译成共享库</h4> <p>这个实验最核心的技术处理，就是在程序的外部，通过另一个进程完成一小段代码到二进制代码的编译。对于一个一行的函数，比如：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span> <span class="o">?</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>编译器可以将它翻译成如下指令序列：</p> <pre><code class="language-assembly">   0:    endbr64 
   4:    mov    %edi,%eax
   6:    test   %esi,%esi
   8:    je     13
   a:    cltd   
   b:    idiv   %esi
   d:    mov    %esi,%eax
   f:    mov    %edx,%esi
  11:    jmp    6
  13:    ret    
</code></pre> <p>我只要试图将这些代码封装在一个动态连接库 (共享库, shared object) 中，这个库就 (gdb 的汇编代码) 就可以被其他程序在运行时加载了。没错，你只需要 <a href="https://niuxintao.github.io/courses/2024Spring-OS/M2/">M2 (libco)</a> 中的编译选项即可。</p> <blockquote class="block-tip"> <h6 id="️选取合适的路径和文件名">☕️选取合适的路径和文件名</h6> <p>如果你的工具在当前目录下创建文件，有可能会失败——例如，你可能在一个没有访问权限的工作目录上 (例如文件系统的根 <code class="language-plaintext highlighter-rouge">/</code>)。在 <code class="language-plaintext highlighter-rouge">/tmp</code> 中创建临时文件是更安全的做法。此外，glibc 还为我们提供了 <code class="language-plaintext highlighter-rouge">mkstemp</code> family API 调用，能够帮助我们生成名称唯一的临时文件。</p> </blockquote> <p>除了编译和命名的问题，大家可能会感到困惑是，如果我的函数调用了其他函数怎么办？</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int foo() { return bar() + baz(); }
</code></pre></div></div> <p>你不妨试着编译这个程序……它竟然可以被编译！所以忽略所有的 warnings 就好了！最后，为了巩固大家在上一个实验中学过的知识，我们限制你不能使用 libc 中的 system 和 popen——它们会让实验变得有些过于简单。</p> <blockquote class="block-tip"> <h6 id="️并不总是可以编译-">☕️并不总是可以编译 😂</h6> <p>有些编译器 (例如 Linux gcc/clang) 会给出一个警告，但警告嘛，我们可以无视。有些编译器的默认行为则是拒绝编译 (例如 macOS clang)。你猜想编译器应该能调控这个行为。于是甚至不用翻手册，AI 就会告诉你 <code class="language-plaintext highlighter-rouge">-Wno-implicit-function-declaration</code> 能够绕过这个检查。</p> </blockquote> <h4 id="43-把表达式编译成共享库">4.3 把表达式编译成共享库</h4> <p>把函数编译成共享库是常规操作——库函数。但表达式怎么办？又用到我们这门课里反复用的小技巧了：我们可以做一个 wrapper 呀！每当我们收到一个表达式，例如 <code class="language-plaintext highlighter-rouge">gcd(256, 144)</code> 的时候，我们都可以 “人工生成” 一段 C 代码</p> <pre><code class="language-C">int __expr_wrapper_4() {
    return gcd(256, 144);
}
</code></pre> <p>注意到函数名里的数字——我们通过加上数字为表达式生成不一样的名字。我们的表达式变成一个函数，我们就可以把它编译成共享库了。把动态库加载到地址空间并得到<code class="language-plaintext highlighter-rouge">__expr_wrapper_4</code> 的地址，直接进行函数调用就能得到表达式的值了。这是一个小小的 hack——但实际上真正的 REPL 也会用类似的方式处理动态生成的代码：给它一个临时的 “名字”。</p> <h4 id="44-共享库的加载">4.4 共享库的加载</h4> <blockquote class="block-tip"> <h6 id="️看看-gpt-是怎么回答的">☕️看看 GPT 是怎么回答的？</h6> <p>Q: 我有一个 <code class="language-plaintext highlighter-rouge">.so</code> 文件。我如何在 C 语言里加载它，并且调用其中定义的函数foo？</p> </blockquote> <p>GPT-4-turbo 回复 (无删节)：在 C 语言中，你可以使用动态链接库 (Dynamic Linking Library) 的功能来加载 <code class="language-plaintext highlighter-rouge">.so</code> 文件并调用其中的函数。<code class="language-plaintext highlighter-rouge">.so</code> 文件是在类 Unix 系统 (如 Linux) 中使用的共享库 (Shared Library) 格式。下面是如何在C语言中加载 <code class="language-plaintext highlighter-rouge">.so</code> 文件并调用其中的 <code class="language-plaintext highlighter-rouge">foo</code> 函数的步骤：</p> <ol> <li> <strong>包含必要的头文件</strong> ：你需要包含 <code class="language-plaintext highlighter-rouge">&lt;dlfcn.h&gt;</code> 头文件，它提供了动态加载库所需的 <code class="language-plaintext highlighter-rouge">dlopen</code>、<code class="language-plaintext highlighter-rouge">dlsym</code> 和 <code class="language-plaintext highlighter-rouge">dlclose</code> 函数。</li> <li> <strong>打开共享库</strong> ：使用 <code class="language-plaintext highlighter-rouge">dlopen()</code> 函数加载 <code class="language-plaintext highlighter-rouge">.so</code> 文件。你需要提供库的路径和加载模式（通常是 <code class="language-plaintext highlighter-rouge">RTLD_LAZY</code> 或 <code class="language-plaintext highlighter-rouge">RTLD_NOW</code>）。</li> <li> <strong>获取函数指针</strong> ：使用 <code class="language-plaintext highlighter-rouge">dlsym()</code> 函数获取共享库中函数的地址。你需要提供 <code class="language-plaintext highlighter-rouge">dlopen</code> 返回的句柄和函数名。</li> <li> <strong>调用函数</strong> ：通过函数指针调用函数。</li> <li> <strong>关闭共享库</strong> ：使用 <code class="language-plaintext highlighter-rouge">dlclose()</code> 关闭加载的库。</li> </ol> <p>下面是一个示例代码，展示如何实现上述步骤：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>  <span class="c1">// 假设foo是一个无参数且返回void的函数</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>

    <span class="c1">// 打开共享库</span>
    <span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"libfoo.so"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dlerror</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 清除现有的错误</span>
    <span class="n">dlerror</span><span class="p">();</span>

    <span class="c1">// 获取foo函数的地址</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>  <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 调用函数</span>
    <span class="n">foo</span><span class="p">();</span>

    <span class="c1">// 关闭共享库</span>
    <span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong> ：</p> <ul> <li>确保在调用 <code class="language-plaintext highlighter-rouge">dlopen()</code> 时提供正确的库路径。如果库不在标准路径中，你需要提供完整路径。</li> <li>使用 <code class="language-plaintext highlighter-rouge">dlsym()</code> 时，你需要正确地处理类型转换，确保函数指针的类型与实际函数的类型匹配。</li> <li>在生产环境中，应该检查每个动态链接函数的返回值以确保操作成功。</li> </ul> <blockquote class="block-warning"> <h6 id="️点评">⚠️点评</h6> <p>AI 生成的代码会给你一种 “我也行” 的错觉——实际上 jyy 在时间压力下，面对必须完成的任务，也经常被迫不加思考地使用 AI 生成的各类代码/命令。但无论如何，在学习阶段，手册都是不可替代的：去读一读 dlopen 相关库函数的手册、elf (5)，“遍历” 式的学习可以让你不仅了解 “这一个知识”，还可以发散地理解与它相关的概念体系。因此，我们不推荐直接让 AI 解决问题。即便你使用了 AI 生成的代码，好好研读和学习也是很有必要的。</p> </blockquote> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Xintao Niu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: December 06, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>